[TOC]



# 一、O(N)命令关注N的数量

在 Redis 中，有一些命令的时间复杂度为 O(N)，其中 N 表示某个参数的数量。这些命令通常与集合、列表和哈希等数据结构相关。

具体而言，以下是几个常见的 O(N) 命令：

1. `SADD`：向集合中添加一个或多个元素。时间复杂度为 O(N)，其中 N 表示要添加的元素数量。
2. `LRANGE`：获取列表中指定范围内的元素。时间复杂度为 O(N)，其中 N 表示要获取的元素数量。
3. `HMSET`：向哈希表中设置一个或多个字段的值。时间复杂度为 O(N)，其中 N 表示要设置的字段数量。

需要注意的是，虽然这些命令的时间复杂度为 O(N)，但在实际使用时，N 的数量通常不会太大，因此它们的性能表现通常还是比较良好的。同时，在 Redis 中，还有很多其他时间复杂度更低的命令，可以根据具体场景选择最适合的命令来操作数据。



# 二、禁用命令

Redis 中的线上禁用命令指的是那些会对服务器性能产生较大负载或者安全风险较高的命令，例如：

1. `FLUSHALL`、`FLUSHDB`：清空整个 Redis 实例或者当前数据库中的所有数据。这两个命令可以导致大量数据被删除，对服务器性能造成极大的影响。
2. `EVAL`、`EVALSHA`：这两个命令可以执行 Lua 脚本，具有非常强大的功能。但如果使用不当，可能会导致服务器性能下降或者出现安全漏洞。
3. `KEYS`：匹配所有符合给定模式的 key，但这个操作非常消耗 CPU 和内存资源，尤其是在 Redis 中 key 数量非常多时

> #### 补充1：
>
> KEYS 命令的时间复杂度为 O(N)，其中 N 表示要匹配的 key 数量。因此，在 Redis 中如果有大量的 key，使用 KEYS 命令会导致 Redis 的 CPU 占用率飙升，甚至可能导致服务崩溃。
>
> 另外，由于 Redis 是单线程执行命令的，当 KEYS 命令执行时间过长时，会阻塞整个 Redis 实例，导致其他客户端的请求无法得到及时响应，进而影响整个系统的稳定性和性能。
>
> 综上所述，为了保证 Redis 的稳定和可靠性，企业通常会禁用 KEYS 命令，并采取其他方式来实现类似的功能。例如，可以使用 SCAN 命令逐步迭代遍历 key，或者在应用设计阶段就考虑到安全因素，将 key 存储在特定的数据结构中，以便快速查找和访问。

Redis提供了一些方法来禁止线上使用高危命令：

1. 通过 Redis 的 rename 机制来禁用命令。比如可以将 keys 命令重命名为其他名称，从而禁止直接使用 keys 命令。

   ```sh
   RENAME keys keys_disabled
   ```

   上述命令将 keys 命令重命名为 keys_disabled，如果用户在尝试执行 keys 命令，会得到一个错误提示。

2. 通过逐步处理的方式来替代高危命令。例如，可以使用 SCAN 命令来逐步迭代遍历所有 key，以此替代 keys 命令。

   ```sh
   SCAN 0 MATCH *
   ```

   上述命令会从第 0 个位置开始，逐步迭代所有 key，并返回匹配 pattern 的 key 列表。使用这种方式可以避免一次性获取所有Key带来的性能问题。

但是，这两种方法都只是一种临时的解决方案。更好的方式是在应用设计阶段就考虑到安全因素，并采取相应的措施来规避风险。



# 三、合理使用select

Redis中的`SELECT`命令用于在一个Redis实例中选择指定的数据库。默认情况下，Redis实例中有16个数据库（编号从0到15），可以使用SELECT命令切换数据库。

合理使用SELECT命令能够减少内存占用和性能开销，提高代码的可维护性。需要考虑的点：

1. 数据库数量：如果Redis实例只使用了少数几个数据库，那么使用SELECT命令进行切换是比较方便的。但是如果使用的数据库数量很多，那么频繁地使用SELECT命令可能会使代码变得复杂且难以维护。
2. 内存占用：每个Redis数据库都需要一定的内存空间来存储数据。如果Redis实例中存在大量的数据库，并且每个数据库中的数据量都很大，那么可能会导致Redis实例的内存占用过高。此时，可以考虑将相关数据放在同一个数据库中，以减少内存占用。
3. 性能开销：使用SELECT命令进行数据库切换时，Redis需要执行额外的操作来切换数据库。因此，频繁地使用SELECT命令可能会对Redis的性能产生一定的影响。为了避免这种情况，可以通过将相关数据放在同一个数据库中来减少切换次数。



# 四、使用批量操作提高效率

Redis支持批量操作的命令，可以有效地提高Redis的效率。

原生命令：

1. `MSET`/`MGET`：MSET命令可以同时设置多个键值对，MGET命令可以同时获取多个键的值。这两个命令可以在一次网络往返中完成多个操作，从而减少了网络延时和通信开销。
2. `DEL`：DEL命令可以同时删除多个键。如果需要删除多个键，那么逐个执行DEL命令会造成不必要的性能开销，可以使用DEL命令批量删除多个键。
3. `EXISTS`：EXISTS命令可以同时检查多个键是否存在。如果需要检查多个键的存在性，那么逐个执行EXISTS命令也会造成不必要的性能开销，可以使用EXISTS命令批量检查多个键的存在性。
4. `INCRBY`/`DECRBY`：INCRBY命令可以同时对多个键进行加法操作，DECRBY命令可以同时对多个键进行减法操作。例如，可以使用INCRBY命令批量增加多个计数器的值。

非原生命令：

`PIPELINE`：Pipeline是一种将多个Redis命令打包到一起发送到Redis服务器的技术，它可以将多个命令在一个网络往返中执行，并且减少了每个命令的通信开销和延时。使用pipeline可以大大提高Redis的性能和吞吐量。

示例代码：

```java
import redis.clients.jedis.Jedis;
import redis.clients.jedis.Pipeline;
import redis.clients.jedis.Response;

/**
 * @author codejuzi
 */
public class RedisPipelineExample {

  public static void main(String[] args) {
    // 创建Jedis对象
    Jedis jedis = new Jedis("localhost", 6379);

    // 创建Pipeline对象
    Pipeline pipeline = jedis.pipelined();

    // 打包多个命令
    pipeline.set("key1", "value1");
    pipeline.set("key2", "value2");
    Response<String> response = pipeline.get("key1");

    // 执行命令
    pipeline.sync();

    // 获取结果
    String result1 = response.get();
    System.out.println(result1);

    // 关闭Jedis连接
    jedis.close();
  }

}
```

📢注意：pipeline并不是完全没有缺点的。由于命令是在一个请求中打包发送到Redis服务器的，因此如果其中一个命令执行失败，则后续的命令都将被忽略。此外，在某些情况下，pipeline可能会导致Redis服务器的CPU负载过高，从而影响其他应用程序的性能。因此，在使用pipeline时需要根据具体情况来选择合适的命令数量和执行方式，以达到最好的性能和稳定性。



# 五、不建议过多使用Redis事务功能

Redis的事务功能可以让多个命令一起执行，从而确保这些命令要么全部执行成功，要么全部失败。然而，虽然Redis事务功能在某些情况下非常有用，但过度使用它也可能导致一些问题。

1. Redis事务不支持回滚，如果其中一个命令执行失败，其他命令也会继续执行。这可能会导致数据不一致或错误结果的产生。
2. 当使用Redis事务时，Redis会将所有命令都缓存在客户端中，并在执行时才将它们发送到Redis服务器。这意味着如果事务中包含大量命令，客户端需要等待很长时间才能收到结果，这可能会影响应用程序的性能。
3. Redis事务的锁定机制可能会影响系统的可伸缩性。当使用事务进行读写操作时，Redis会对相应的键进行锁定，这意味着其他客户端无法访问该键直到事务完成。这可能会导致潜在的竞争条件和性能问题。

因此，在使用Redis时，建议谨慎使用事务功能，并根据具体情况进行合理的优化和调整，以确保应用程序的性能和可伸缩性。

> #### 补充2：应用的可伸缩性
>
> 应用的可伸缩性（Scalability）是指一个应用程序能够在需要时轻松地扩展以处理更多的负载和用户请求，而不会影响其性能、可靠性和可用性。一个具有良好可伸缩性的应用程序能够有效地处理高峰值流量和数据存储需求，并随着业务增长自动扩展。



# 六、Redis集群在使用Lua脚本的特殊要求

在Redis集群中使用Lua脚本时，需要注意以下几点：

1. Redis集群模式下，不支持对多个key进行写操作。因此，在编写Lua脚本时，应该尽量避免对多个key同时进行写操作。如果要写入多个key，请将它们分别传递给Lua脚本，并在脚本内部依次执行写操作。
2. Redis集群中，每个节点只存储部分数据，因此，在运行Lua脚本时，应该确保操作的key都被存储在同一个节点上。可以使用Redis提供的`MOVED`和`ASK`命令来进行重定向和询问操作。例如，当调用写操作时，如果key所在的槽位没有在当前节点上，则节点会返回`MOVED`错误，此时客户端需要根据返回的信息重新连接到正确的节点上。
3. 在Redis集群中，由于各个节点之间可能存在网络延迟或者数据同步的问题，因此并不能保证所有节点的数据是完全一致的。因此，当在Lua脚本中进行读取操作时，需要注意有可能出现读到旧数据的情况。为了解决这个问题，可以使用Redis提供的`READONLY`命令，将当前节点切换为只读模式，这样就可以确保读取到最新的数据。

# 七、不要长时间使用MONITOR命令

Redis的`MONITOR`命令用于实时监控Redis服务器接收到的所有命令，并将这些命令输出到客户端，以便进行调试和分析。但是，必要情况下使用monitor命令时，要注意不要长时间使用。原因如下：

1. 资源消耗：当使用`MONITOR`命令时，Redis会记录下每个客户端发送的命令，并将这些信息输出到客户端。由于Redis的性能非常高，因此在高并发环境下，`MONITOR`命令可能会导致服务器资源消耗过高，从而影响Redis的性能和稳定性。
2. 安全问题：`MONITOR`命令不受任何限制地输出所有的Redis命令，包括敏感信息（如密码等）。如果在生产环境中长时间运行`MONITOR`命令，有可能会泄漏敏感信息，从而带来安全风险。

因此，在生产环境中，建议避免长时间使用`MONITOR`命令，并尽可能少地使用它。

如果需要对Redis进行调试和分析，可以使用Redis提供的其他工具，比如：showlog、redis-cli等。同时，为了确保系统的安全性和可靠性，应该采取适当的安全措施，如禁止远程访问、使用密码认证等。